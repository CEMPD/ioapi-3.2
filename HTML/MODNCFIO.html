
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id: MODNCFIO.html 3 2017-04-13 14:54:46Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE">
<TITLE>MODULE MODNCFIO</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF"
      TOPMARGIN="15"
      MARGINHEIGHT="15"
      LEFTMARGIN="15"
      MARGINWIDTH="15">

<!--#include virtual="/INCLUDES/header.html" -->

<H1>    Fortran-90 <CODE>MODULE&nbsp;MODNCFIO</CODE> </H1>

<H2>Summary</H2>

<BLOCKQUOTE>

    <EM>New for I/O&nbsp;API-3.2!!</EM>
    <P>
    Developed from (extends, and resolves inconsistencies in) the
    I/O&nbsp;API/netCDF/PnetCDF INCLUDE-files <CODE>NETCDF.EXT</CODE>
    and <CODE>pnetcdf.inc</CODE> (which declare [p]netCDF  routines
    and related constants), and also includes new routines for
    inquiring about, and reading, variables from &quot;raw&quot; netCDF
    files.
    <P>

</BLOCKQUOTE>

<H2>Declarations</H2>

<BLOCKQUOTE>

    This module is mostly a &quot;declarations-module&quot;, which is
    used to resolve various incompatibilities between  different
    versions of netCDF and (if <A HREF="BUFFERED.html#pncf">PnetCDF/MPI
    distributed I/O</A> is enabled)_PnetCDF INCLUDE-files.  The options
    are controlled by preprocessor symbols at <VAR>libioapi.a</VAR>
    build-time:
    <UL>
        <LI> If <CODE>IOAPI_PNCF</CODE> is defined (as it is in
             <VAR>Makefile.pncf</VAR>), then <U>PnetCDF/MPI distributed
             I/O</U> is enabled.
             <P>
        <LI> If <CODE>IOAPI_NCF4</CODE> is defined (it is commented-out
             in the <VAR>Makefile.*</VAR>), then the <U>new NetCDF-4
             features</U> are enabled (including 64-bit-<CODE>INTEGER</CODE>
             variables and attributes, and HDF file-formats).
             <P>
        <LI> Otherwise, only the &quot;traditional&quot; netCDF-3
             routines and parameters are turned on.
             64-bit-<CODE>INTEGER</CODE> operations will return failure,
             and write an appropriate error message.
    </UL>
    This of course leads to four (link-incompatible!) distinct
    netCDF-version related versions of the I/O&nbsp;API library (and
    the additional option for PVM-enabled or not, as distinguished by
    preprocessor symbol <CODE>IOAPICPL</CODE> defined in
    <VAR>Makefile.cpl</VAR>, turns it into a total of 8 versions in
    all).
    <P>

    It is also hoped that the source code for this module is somewhat
    more readable than the original <CODE>INCLUDE</CODE>-files&nbsp;:-)
    <P>

</BLOCKQUOTE>

<H2>New Routines:</H2>

<BLOCKQUOTE>

    <H3><CODE>DESCNCVAR</CODE></H3>
    <PRE>
    LOGICAL FUNCTION DESCNCVAR( FNAME, MXVAR, NVARS, VNAMES, VTYPES, VNDIMS, VDIMS )
        CHARACTER*(*), INTENT(IN   ) :: FNAME           !!  logical file name
        INTEGER      , INTENT(IN   ) :: MXVAR           !!  max # of vbles returned
        INTEGER      , INTENT(  OUT) :: NVARS           !!  min( MXVAR, actual # of vbles )
        CHARACTER*(*), INTENT(  OUT) :: VNAMES( MXVAR ) !!  variable names
        CHARACTER*(*), INTENT(  OUT) :: VUNITS( MXVAR ) !!  variable units
        INTEGER      , INTENT(  OUT) :: VTYPES( MXVAR ) !!  types (M3REAL, M3INT, etc.)
        INTEGER      , INTENT(  OUT) :: VNDIMS( MXVAR ) !!  ranks (number of dimensions)
        INTEGER      , INTENT(  OUT) :: VDIMS(7,MXVAR ) !!  dimensions
    </PRE>
    For a given netCDF file with logical name <CODE>FNAME</CODE> and maximum
    list-size <CODE>MXVAR</CODE>, returns lists giving the names, data-types,
    numbers of dimensions, and dimensions for the variables in that file.
    Opens the file before inquiring from its header, and closes it before
    return to the caller.
    <P>

    <STRONG>Preconditions:</STRONG>:<BR>
    <BLOCKQUOTE>
    <VAR>setenv &lt;logical-name&gt; &lt;path-name&gt;</VAR><BR>
    Also make sure the string-length for <CODE>VNAMES(*)</CODE> is long enough
    to hold the variable-names that occur in the file.
    <P>
    Presumes that the file follows standard netCDF conventions and does
    have a <CODE>units</CODE> attribute for each variable (which MPAS
    fails to do, by the way).
    </BLOCKQUOTE>


    <H3><CODE>READNCVAR</CODE></H3>
    <PRE>
    LOGICAL FUNCTION READNCVAR( FNAME, VNAME, [NCOLS, [NROWS, [NLAYS, [NSPCS, ]]]] GRID )
    LOGICAL FUNCTION READNCVAR0DI( FNAME, VNAME, IGRID0 )
    LOGICAL FUNCTION READNCVAR0DS( FNAME, VNAME, SGRID0 )
    LOGICAL FUNCTION READNCVAR0DB( FNAME, VNAME, BGRID0 )
    LOGICAL FUNCTION READNCVAR0DR( FNAME, VNAME, RGRID0 )
    LOGICAL FUNCTION READNCVAR0DD( FNAME, VNAME, DGRID0 )
    LOGICAL FUNCTION READNCVAR1DI( FNAME, VNAME, NCOLS, IGRID1 )
    LOGICAL FUNCTION READNCVAR1DS( FNAME, VNAME, NCOLS, SGRID1 )
    LOGICAL FUNCTION READNCVAR1DB( FNAME, VNAME, NCOLS, BGRID1 )
    LOGICAL FUNCTION READNCVAR1DR( FNAME, VNAME, NCOLS, RGRID1 )
    LOGICAL FUNCTION READNCVAR1DD( FNAME, VNAME, NCOLS, DGRID1 )
    LOGICAL FUNCTION READNCVAR2DI( FNAME, VNAME, NCOLS, NROWS, IGRID2 )
    LOGICAL FUNCTION READNCVAR2DS( FNAME, VNAME, NCOLS, NROWS, SGRID2 )
    LOGICAL FUNCTION READNCVAR2DB( FNAME, VNAME, NCOLS, NROWS, BGRID2 )
    LOGICAL FUNCTION READNCVAR2DR( FNAME, VNAME, NCOLS, NROWS, RGRID2 )
    LOGICAL FUNCTION READNCVAR2DD( FNAME, VNAME, NCOLS, NROWS, DGRID2 )
    LOGICAL FUNCTION READNCVAR3DI( FNAME, VNAME, NCOLS, NROWS, NLAYS, IGRID3 )
    LOGICAL FUNCTION READNCVAR3DI( FNAME, VNAME, NCOLS, NROWS, NLAYS, SGRID3 )
    LOGICAL FUNCTION READNCVAR3DS( FNAME, VNAME, NCOLS, NROWS, NLAYS, BGRID3 )
    LOGICAL FUNCTION READNCVAR3DB( FNAME, VNAME, NCOLS, NROWS, NLAYS, RGRID3 )
    LOGICAL FUNCTION READNCVAR3DD( FNAME, VNAME, NCOLS, NROWS, NLAYS, DGRID3 )
    LOGICAL FUNCTION READNCVAR4DI( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, IGRID4 )
    LOGICAL FUNCTION READNCVAR4DI( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, SGRID4 )
    LOGICAL FUNCTION READNCVAR4DS( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, BGRID4 )
    LOGIC4L FUNCTION READNCVAR4DB( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, RGRID4 )
    LOGICAL FUNCTION READNCVAR4DD( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, DGRID4 )
    LOGICAL FUNCTION READNCVEC2DI( FNAME, VNAME, NCOLS, NROWS, IVEC2 )
    LOGICAL FUNCTION READNCVEC2DS( FNAME, VNAME, NCOLS, NROWS, SVEC2 )
    LOGICAL FUNCTION READNCVEC2DB( FNAME, VNAME, NCOLS, NROWS, BVEC2 )
    LOGICAL FUNCTION READNCVEC2DR( FNAME, VNAME, NCOLS, NROWS, RVEC2 )
    LOGICAL FUNCTION READNCVEC2DD( FNAME, VNAME, NCOLS, NROWS, DVEC2 )
    LOGICAL FUNCTION READNCVEC3DI( FNAME, VNAME, NCOLS, NROWS, NLAYS, IVEC3 )
    LOGICAL FUNCTION READNCVEC3DS( FNAME, VNAME, NCOLS, NROWS, NLAYS, SVEC3 )
    LOGICAL FUNCTION READNCVEC3DB( FNAME, VNAME, NCOLS, NROWS, NLAYS, BVEC3 )
    LOGICAL FUNCTION READNCVEC3DR( FNAME, VNAME, NCOLS, NROWS, NLAYS, RVEC3 )
    LOGICAL FUNCTION READNCVEC3DD( FNAME, VNAME, NCOLS, NROWS, NLAYS, DVEC3 )
    LOGICAL FUNCTION READNCVEC4DI( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, IVEC4 )
    LOGICAL FUNCTION READNCVEC4DS( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, SVEC4 )
    LOGICAL FUNCTION READNCVEC4DB( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, BVEC4 )
    LOGICAL FUNCTION READNCVEC4DR( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, RVEC4 )
    LOGICAL FUNCTION READNCVEC4DD( FNAME, VNAME, NCOLS, NROWS, NLAYS, NSPCS, DVEC4 )
    LOGICAL FUNCTION READNVSTEP0DS( FNAME, ISTEP, VNAME, SGRID0 )
    LOGICAL FUNCTION READNVSTEP0DB( FNAME, ISTEP, VNAME, BGRID0 )
    LOGICAL FUNCTION READNVSTEP0DR( FNAME, ISTEP, VNAME, RGRID0 )
    LOGICAL FUNCTION READNVSTEP0DD( FNAME, ISTEP, VNAME, DGRID0 )
    LOGICAL FUNCTION READNVSTEP1DI( FNAME, ISTEP, VNAME, NCOLS, IGRID1 )
    LOGICAL FUNCTION READNVSTEP1DS( FNAME, ISTEP, VNAME, NCOLS, SGRID1 )
    LOGICAL FUNCTION READNVSTEP1DB( FNAME, ISTEP, VNAME, NCOLS, BGRID1 )
    LOGICAL FUNCTION READNVSTEP1DR( FNAME, ISTEP, VNAME, NCOLS, RGRID1 )
    LOGICAL FUNCTION READNVSTEP1DD( FNAME, ISTEP, VNAME, NCOLS, DGRID1 )
    LOGICAL FUNCTION READNVSTEP2DI( FNAME, ISTEP, VNAME, NCOLS, NROWS, IGRID2 )
    LOGICAL FUNCTION READNVSTEP2DS( FNAME, ISTEP, VNAME, NCOLS, NROWS, SGRID2 )
    LOGICAL FUNCTION READNVSTEP2DB( FNAME, ISTEP, VNAME, NCOLS, NROWS, BGRID2 )
    LOGICAL FUNCTION READNVSTEP2DR( FNAME, ISTEP, VNAME, NCOLS, NROWS, RGRID2 )
    LOGICAL FUNCTION READNVSTEP2DD( FNAME, ISTEP, VNAME, NCOLS, NROWS, DGRID2 )
    LOGICAL FUNCTION READNVSTEP3DI( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, IGRID3 )
    LOGICAL FUNCTION READNVSTEP3DI( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, SGRID3 )
    LOGICAL FUNCTION READNVSTEP3DS( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, BGRID3 )
    LOGICAL FUNCTION READNVSTEP3DB( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, RGRID3 )
    LOGICAL FUNCTION READNVSTEP3DD( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, DGRID3 )
    LOGICAL FUNCTION READNVSTEP4DI( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, NSPCS, IGRID4 )
    LOGICAL FUNCTION READNVSTEP4DI( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, NSPCS, SGRID4 )
    LOGICAL FUNCTION READNVSTEP4DS( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, NSPCS, BGRID4 )
    LOGIC4L FUNCTION READNVSTEP4DB( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, NSPCS, RGRID4 )
    LOGICAL FUNCTION READNVSTEP4DD( FNAME, ISTEP, VNAME, NCOLS, NROWS, NLAYS, NSPCS, DGRID4 )
        CHARACTER*(*), INTENT(IN   ) :: FNAME                !!  logical file name
        CHARACTER*(*), INTENT(IN   ) :: VNAME                !!  variable name
        INTEGER      , INTENT(IN   ) :: ISTEP                !!  time-step number (1,2,3,...)
        INTEGER      , INTENT(IN   ) :: NCOLS, NROWS, NLAYS, NSPCS  !!  dimensions
        &lt;type&gt;       , INTENT(  OUT) ::  GRID ( NCOLS, [NROWS, [NLAYS,[NSPCS]]] )
        INTEGER      , INTENT(  OUT) :: IGRID0
        REAL         , INTENT(  OUT) :: RGRID0
        REAL*8       , INTENT(  OUT) :: DGRID0
        INTEGER      , INTENT(  OUT) :: IGRID1( NCOLS )
        INTEGER*2    , INTENT(  OUT) :: SGRID1( NCOLS )
        INTEGER*1    , INTENT(  OUT) :: BGRID1( NCOLS )
        REAL         , INTENT(  OUT) :: RGRID1( NCOLS )
        REAL*8       , INTENT(  OUT) :: DGRID1( NCOLS )
        INTEGER      , INTENT(  OUT) :: IGRID2( NCOLS, NROWS )
        INTEGER*2    , INTENT(  OUT) :: SGRID2( NCOLS, NROWS )
        INTEGER*1    , INTENT(  OUT) :: BGRID2( NCOLS, NROWS )
        REAL         , INTENT(  OUT) :: RGRID2( NCOLS, NROWS )
        REAL*8       , INTENT(  OUT) :: DGRID2( NCOLS, NROWS )
        INTEGER      , INTENT(  OUT) :: IGRID3( NCOLS, NROWS, NLAYS )
        INTEGER*2    , INTENT(  OUT) :: SGRID3( NCOLS, NROWS, NLAYS )
        INTEGER*1    , INTENT(  OUT) :: BGRID3( NCOLS, NROWS, NLAYS )
        REAL         , INTENT(  OUT) :: RGRID3( NCOLS, NROWS, NLAYS )
        REAL*8       , INTENT(  OUT) :: DGRID3( NCOLS, NROWS, NLAYS )
        INTEGER      , INTENT(  OUT) :: IGRID4( NCOLS, NROWS, NLAYS, NSPCS )
        INTEGER*2    , INTENT(  OUT) :: SGRID4( NCOLS, NROWS, NLAYS, NSPCS )
        INTEGER*1    , INTENT(  OUT) :: BGRID4( NCOLS, NROWS, NLAYS, NSPCS )
        REAL         , INTENT(  OUT) :: RGRID4( NCOLS, NROWS, NLAYS, NSPCS )
        REAL*8       , INTENT(  OUT) :: DGRID4( NCOLS, NROWS, NLAYS, NSPCS )
        INTEGER      , INTENT(  OUT) ::  IVEC2( NCOLS*NROWS )
        INTEGER*2    , INTENT(  OUT) ::  SVEC2( NCOLS*NROWS )
        INTEGER*1    , INTENT(  OUT) ::  BVEC2( NCOLS*NROWS )
        REAL         , INTENT(  OUT) ::  RVEC2( NCOLS*NROWS )
        REAL*8       , INTENT(  OUT) ::  DVEC2( NCOLS*NROWS )
        INTEGER      , INTENT(  OUT) ::  IVEC3( NCOLS*NROWS*NLAYS )
        INTEGER*2    , INTENT(  OUT) ::  SVEC3( NCOLS*NROWS*NLAYS )
        INTEGER*1    , INTENT(  OUT) ::  BVEC3( NCOLS*NROWS*NLAYS )
        REAL         , INTENT(  OUT) ::  RVEC3( NCOLS*NROWS*NLAYS )
        REAL*8       , INTENT(  OUT) ::  DVEC3( NCOLS*NROWS*NLAYS )
        INTEGER      , INTENT(  OUT) ::  IVEC4( NCOLS*NROWS*NLAYS*NSPCS )
        INTEGER*2    , INTENT(  OUT) ::  SVEC4( NCOLS*NROWS*NLAYS*NSPCS )
        INTEGER*1    , INTENT(  OUT) ::  BVEC4( NCOLS*NROWS*NLAYS*NSPCS )
        REAL         , INTENT(  OUT) ::  RVEC4( NCOLS*NROWS*NLAYS*NSPCS )
        REAL*8       , INTENT(  OUT) ::  DVEC4( NCOLS*NROWS*NLAYS*NSPCS )
    </PRE>
    Generic and type/dimension-count specific routines for reading either
    entire-file or timestep-slice of 0-D, 1-D, 2-D, 3-D, and 4-D
    <CODE>NF_INT1, NF_INT2, M3INT, M3REAL</CODE> and <CODE>M3DBLE</CODE>
    variables from &quot;raw&quot; netCDF files.
    <P>

    <STRONG>Preconditions and Limitations:</STRONG>:<BR>
    <VAR>setenv &lt;logical-name&gt; &lt;path-name&gt;</VAR><BR>
    <CODE>VNAME</CODE> must exactly match the name of a variable in the file.<BR>
    The dimensions given as arguments must exactly match the dimensions
    for that variable in that file.<BR>
    For time stepped variables (or variables having
    netCDF-unlimited as a dimension), supports only
    &quot;whole-variable&quot; read operations.<BR>
    Output-array must be dimensioned as shown above.
    <P>

    Note that the time stepped forms have a somewhat-unexpected
    <CODE>FNAME,&nbsp;ISTEP,&nbsp;VNAME,&nbsp;...</CODE> order of
    arguments; this is a consequence of the need to have unique
    argument-list specifications for the compiler to be able to
    distinguish which specific function-version is appropriate.
    <P>

</BLOCKQUOTE>

<HR> <!- ------------------------------------------------------------- ->

<A HREF = "AA.html">
To: <STRONG>Models-3/EDSS I/O API:  The Help Pages</STRONG>
</A><P>


Send comments to
<A HREF = "mailto:carlie@jyarborough.com"> <ADDRESS>
          Carlie J. Coats, Jr. <br>
          carlie@jyarborough.com  </ADDRESS> </A><P>

<!--#include virtual="/INCLUDES/footer.html" -->


</BODY>
</HTML>

